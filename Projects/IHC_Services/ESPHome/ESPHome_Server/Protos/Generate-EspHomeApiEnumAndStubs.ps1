
param(
  [string] $ProtoPath = "./api.proto",

  [string] $Namespace = 'ESPHome_Server',
  [string] $ClientClassName = 'SessionBase',

  # Where to write the generated .cs; parent directory is auto-created
  [string] $OutPath = '../EspHome.NativeApi.cs',

  # If parsing finds 0 RPCs or 0 messages, by default we abort.
  # Set -AllowEmpty to still produce an output file (useful for debugging).
  [switch] $AllowEmpty
)

# Make errors stop the script
$ErrorActionPreference = 'Stop'

function Write-DebugBlock([string]$Title, [string]$Text) {
  Write-Verbose ("--- {0} ---" -f $Title)
  foreach ($line in ($Text -split "`r?`n")) { Write-Verbose $line }
  Write-Verbose ("--- end {0} ---" -f $Title)
}

# Validate input file
if (-not (Test-Path -LiteralPath $ProtoPath)) {
  throw "File not found: $ProtoPath"
}

Write-Verbose "Reading proto: $ProtoPath"
$protoText = Get-Content -LiteralPath $ProtoPath -Raw
if ([string]::IsNullOrWhiteSpace($protoText)) {
  throw "Proto file appears empty: $ProtoPath"
}

# Regexes for messages and IDs
$messageRegex = [regex]::new('(?s)message\s+(?<name>\w+)\s*\{(?<body>.*?)\}', 'Compiled')
$idRegex      = [regex]::new('option\s*\(\s*id\s*\)\s*=\s*(?<id>\d+)\s*;', 'Compiled')

# Collect message IDs
$messages = @()
foreach ($m in $messageRegex.Matches($protoText)) {
  $name = $m.Groups['name'].Value
  $body = $m.Groups['body'].Value
  $idMatch = $idRegex.Match($body)
  if ($idMatch.Success) {
    $id = [int]$idMatch.Groups['id'].Value
    $messages += [pscustomobject]@{ Name = $name; Id = $id }
  }
}

Write-Verbose ("Found {0} messages with IDs." -f $messages.Count)

# De-duplicate by Id, keep first, then sort by Id
$messages = $messages |
  Group-Object Id | ForEach-Object { $_.Group | Select-Object -First 1 } |
  Sort-Object Id

# name -> id map
$nameToId = @{}
foreach ($msg in $messages) { $nameToId[$msg.Name] = $msg.Id }

# --- Balanced-brace extraction of `service APIConnection { ... }` ---
$serviceStart = [regex]::Match($protoText, 'service\s+APIConnection\s*\{', 'IgnoreCase')
if (-not $serviceStart.Success) {
  throw "Could not find 'service APIConnection {' in proto. (Search is case-insensitive.)"
}

$startIdx = $serviceStart.Index
$openIdx = $protoText.IndexOf('{', $startIdx)
if ($openIdx -lt 0) {
  throw "Found 'service APIConnection' but no opening '{'."
}

$depth = 0
$endIdx = -1
for ($i = $openIdx; $i -lt $protoText.Length; $i++) {
  $ch = $protoText[$i]
  if ($ch -eq '{') { $depth++ }
  elseif ($ch -eq '}') {
    $depth--
    if ($depth -eq 0) {
      $endIdx = $i
      break
    }
  }
}

if ($endIdx -lt 0) {
  throw "Failed to find matching closing '}' for service APIConnection."
}

# Extract the full service body between the outer braces
$serviceBody = $protoText.Substring($openIdx + 1, $endIdx - $openIdx - 1)

# --- RPC parsing over the extracted service body ---
# Permissive match for: rpc <Name>(<Req>) returns (<Resp|void>) { ... }
$rpcRegex = [regex]::new(
  'rpc\s+(?<rpc>\w+)\s*\(\s*(?<req>\w+)\s*\)\s*returns\s*\(\s*(?<resp>\w+|void)\s*\)\s*\{',
  'Compiled'
)

$rpcs = @()
foreach ($r in $rpcRegex.Matches($serviceBody)) {
  $rpcs += [pscustomobject]@{
    RpcName  = $r.Groups['rpc'].Value
    ReqType  = $r.Groups['req'].Value
    RespType = $r.Groups['resp'].Value
  }
}

Write-Verbose ("Found {0} RPCs." -f $rpcs.Count)

# Optional: dump first 10 rpc lines for debugging
if ($rpcs.Count -gt 0) {
  $preview = ($rpcs | Select-Object -First 10 | ForEach-Object {
    "{0}({1}) returns ({2})" -f $_.RpcName, $_.ReqType, $_.RespType
  }) -join [Environment]::NewLine
  Write-DebugBlock -Title 'RPC preview' -Text $preview
} else {
  Write-DebugBlock -Title 'Service body (first 200 chars)' -Text ($serviceBody.Substring(0, [Math]::Min(200, $serviceBody.Length)))
}

function Sanitize-CSIdentifier([string] $name) {
  $s = [regex]::Replace($name, '[^A-Za-z0-9_]', '_')
  if ($s.Length -gt 0 -and ($s[0] -match '\d')) { $s = '_' + $s }
  return $s
}

# Build C# output
$outLines = @()

# Header
$outLines += '// <auto-generated>'
$outLines += '// Generated from ESPHome api.proto'
$outLines += '// Repo: https://github.com/esphome/esphome/blob/dev/esphome/components/api/api.proto'
$outLines += '// NOTE: Regenerate whenever you update ESPHome (IDs or RPCs may change).'
$outLines += '// </auto-generated>'
$outLines += ''
$outLines += 'using System;'
$outLines += 'using System.Threading;'
$outLines += 'using System.Threading.Tasks;'
$outLines += 'using System.Net.Sockets;'
$outLines += ''
$outLines += "namespace $Namespace"
$outLines += '{'

# Enum
$outLines += '    /// <summary>'
$outLines += '    /// ESPHome Native API message type IDs (wire preamble VarInt).'
$outLines += '    /// Source: api.proto option(id)=N'
$outLines += '    /// </summary>'
$outLines += '    public enum EspHomeApiMessageId'
$outLines += '    {'

foreach ($m in $messages) {
  $outLines += "        $(Sanitize-CSIdentifier $m.Name) = $($m.Id),"
}

$outLines += '    }'
$outLines += ''

# Client class
$outLines += '    /// <summary>'
$outLines += '    /// Minimal client stub for ESPHome Native API.'
$outLines += '    /// </summary>'
$outLines += "    public class $ClientClassName"
$outLines += '    {'
$outLines += '        protected NetworkStream? networkStream;'
$outLines += ''


$TextInfo = (Get-Culture).TextInfo

foreach ($rpc in $rpcs) {
  $rpcName = Sanitize-CSIdentifier($rpc.RpcName)
  $rpcName = $TextInfo.ToTitleCase($rpcName)
  $reqType = Sanitize-CSIdentifier($rpc.ReqType)
  $respTypeRaw = $rpc.RespType
  $hasResponse = $true
  if ($respTypeRaw -eq 'void') { $hasResponse = $false }

  $respType = $null
  if ($hasResponse) { $respType = Sanitize-CSIdentifier($respTypeRaw) }

  # Resolve IDs (fall back to -1 if not found)
  $reqId = -1
  if ($nameToId.ContainsKey($rpc.ReqType)) { $reqId = $nameToId[$rpc.ReqType] }

  $respId = -1
  if ($hasResponse -and $nameToId.ContainsKey($respTypeRaw)) { $respId = $nameToId[$respTypeRaw] }

  if (-not $hasResponse) {
    $outLines += "        /// RPC $($rpc.RpcName)($reqType) returns (void)"
    $outLines += "        public virtual async Task ${rpcName}Async($reqType request, CancellationToken ct = default) { return Task.CompletedTask; }"
#    $outLines += "            => SendAsync(EspHomeApiMessageId.$(Sanitize-CSIdentifier($rpc.RespType)), request, ct);"
    $outLines += ''
  }
  else {
    $outLines += "        /// RPC $($rpc.RpcName)($reqType) returns ($respType)"
    $outLines += "        public virtual async Task ${rpcName}Async($reqType request, CancellationToken ct = default)"
    $outLines += '        {'
    $outLines += "            await FrameHelper.WriteMessageAsync(networkStream, EspHomeApiMessageId.$(Sanitize-CSIdentifier($rpc.RespType)), request, ct).ConfigureAwait(false);"
    $outLines += '        }'
    $outLines += ''
  }
}

$outLines += "    } // class $ClientClassName"
$outLines += ''
$outLines += "} // namespace $Namespace"

# --- Decide if we should write ---
if (-not $AllowEmpty) {
  if ($messages.Count -eq 0) {
    throw "Parser found 0 messages with IDs. Refusing to write. (Pass -AllowEmpty to force.)"
  }
  if ($rpcs.Count -eq 0) {
    throw "Parser found 0 RPCs in service APIConnection. Refusing to write. (Pass -AllowEmpty to force.)"
  }
}

# Ensure parent directory exists
$parent = Split-Path -Parent $OutPath
if ([string]::IsNullOrWhiteSpace($parent)) {
  # OutPath is just a filename in current directory, OK
} elseif (-not (Test-Path -LiteralPath $parent)) {
  Write-Verbose "Creating output directory: $parent"
  New-Item -ItemType Directory -Path $parent -Force | Out-Null
}

# Write file as UTF-8 (no BOM)
try {
  $outDir = Get-Location
  $fullPath = Join-Path $outDir $OutPath
  Write-Verbose "Writing output to: $fullPath"
  $utf8NoBom = New-Object System.Text.UTF8Encoding($false)
  $content   = ($outLines -join [Environment]::NewLine)
  [System.IO.File]::WriteAllText($fullPath, $content, $utf8NoBom)

  Write-Host ("Generated C# file: {0} ({1} lines)" -f $fullPath, $outLines.Count)
}
catch {
  Write-Warning ("Failed to write to '{0}': {1}" -f $OutPath, $_.Exception.Message)
  Write-Warning "Echoing generated content to console for copy-paste:"
  # Fallback to console (so you don't lose the generated code)
  $outLines -join [Environment]::NewLine
}
